# Paul Shapiro
_**Challenges in Building Software with Monero Code**_  

Paul Shapiro is a veteran software application and UI developer with a focus on interaction and product design and code quality. He serves as the CEO and lead dev at [MyMonero](https://mymonero.com/), is a Monero codebase contributor, and lives in Nashville, TN where he enjoys rock climbing and tending to his garden.  

**Challenges in Building Software with Monero Code**  
_Paul Shapiro, MyMonero_  
[youtu.be/DY0iE0cBXbc](https://youtu.be/DY0iE0cBXbc)  

_**Abstract**_  

This talk will examine the approaches taken by different third- and first-party Monero core code integrators like MyMonero, Cake Wallet, Monerujo, Monero official GUI, Monero simplewallet, and the new Monero lightwallet server. Trade-offs of different approaches and suggestions of future directions will be discussed. All of the above integrators share code and should share more code. Monero as a FOSS project is relatively unique in the pace of its development, leading to unique challenges. The impact of these challenges will be discussed, and alternatives will be given.  

_**Transcript**_

My name is Paul Shapiro. I'm the CEO at [MyMonero](https://mymonero.com/), which is a wallet software company. We also do some contributions to Monero itself, primarily in the form of initial factoring in code quality improvements, and we've also contributed a [light wallet](https://www.monerooutreach.org/stories/monero_wallet_quickstart.php) server to the Monero codebase. And I'll get into that a little bit more. I guess that's the clicker. So, everyone is having trouble with this clicker, here we go. Might be the table? I think so it's a Faraday table.So just to introduce Monero a little bit Monero is a free and open source project. There's no corporation or single-lead architect behind it. And its codebase, as a few other people have touched upon, is from unknown authors, began without comments or the comments were sort of intentionally ripped out, or something like that. And it borrowed multiple components from somewhat unknown sources. One of them is a library which is known as [epee](https://github.com/monero-project/monero/tree/master/contrib/epee), which is sort of a utility class. And it also has these custom wire formats, which are pretty strange. Development progress is decentralized across hundreds of contributors around the world, so it's a massive open source project. And as a result, it's really hard to put the project itself on pause and say, "Okay guys. Let's stop writing code. Lets kind of re-simplify things, re-figure out what the overall architecture has to be or the overall project requirements are," because that's just a natural part of writing software. You have to occasionally kind of review everything and say, "Okay. Let's re-engineer things with a known problem description instead of just this sort of amorphous fluid description that's evolved over time." 

So the complexity of the existing code makes extending it and integrating with it very difficult. So there's tons of ground for me to cover in a short period of time. I thought it was actually 15 minutes. Turns out it's a little bit longer. I'm gonna zoom through anyway. I managed to stick an emoji in my talk. We have a legacy of code. So basically there's epee, which is this kind of kitchen sink utility library, witch is just tons and tons and tons of things inside of it, which is, as a kitchen sink, it's a sort of notoriously bad thing to do in your codebases. And I'll get into why later. The core crypto itself is actually relatively well-factored. Not everything is impeccably named, and that leads to some inefficiencies in improving, or optimizing, the codebase. Because it's a question of readability of the actual results that you're obtaining as you perform all these different calculations as you go along. There's also something called Simplewallet. Everyone knows about this CLI application. That's Simplewallet in the code. They call it Simplewallet. And then the backing, the business logic backing of that is called wallet2. So Simplewallet's great. Wallet2 is very complicated. The code that the Monero project inherited originally had multiple sources of contribution, to begin with. So it's like multiple authors, to begin with. 

So this talk is going to be about the fact that the original MyMonero.com, the company that I work on - it's a web wallet - had core architecture which was originally the core Monero cryptography trans-piled into [ASMJS](https://emscripten.org/), which is just sort of an ASM look-alike that can run in the browser as native JS. And then there was a whole bunch of handwritten vendor JavaScript stuck on top of that. And the reason that we did that was because as a light wallet the spend key is never sent to the server it's always kept in the browser. So transactions are constructed in the browser, key images are calculated in the browser to determine how much of the balance has already been spent, and Monero has these periodic six-month mandatory security upgrades, aka hard forks, and so the sustainability of re-implementing all of this transaction construction and key image generation and key generation, key derivation stuff, was untenable. It became untenable over time, at least for, sort of, a one- or two-person shop. So we needed a new solution, and the idea was like, "Okay, let's try to trans-pile all of the C++ code that's necessary to kind of implement all the transaction construction, stuff like that." But there was a wall that was hit, which was that the Monero code is largely much too tangled and complicated, has way too many dependencies. So this talk is one in which Endogenic, which is my online handle that I'm stuck with, apparently, complains about Monero's code quality, but don't get me wrong, I actually have tons of respect for the major code contributors like Moneromooo and people like that. And I'd like to give a major shout-out to them because they are the collective bomb.

So epee: contrib/epee is an inherited library. It contains code for--I'm glad I took notes on this here--it contains code for wipe-able memory, regular expressions, logging, compiler warnings, hashing algorithms, "misc" language utils, whatever that means, tons of TCP and HTTP server code, client code, authentication code (And all this stuff, like the TCP and HTTP stuff, we shouldn't even have written that, or it shouldn't be vendored. It should basically be, generally speaking, it should be stuff that we're using an existing, well-maintained library to implement.) Bunch of math helper code, profiling, like time profiling performance, hex coding, command line stuff, JSON parsing. So what is epee scope, exactly? If we look at the set of functionality described by those modules there, what is epee's actual scope? Why doesn't this stuff go somewhere else and why doesn't more stuff go into epee? 

So ambiguous domain scopes lead to code duplication, like epee and this other directory [source/serialization](https://github.com/monero-project/monero/tree/master/src/serialization). Both contain separate parsing code, each was written for formats that we've never seen before, and they're also different; one is for the peer-to-peer protocol and the others for transactions and blocks. Did I get that right? So there's this other directory in there called [src/common](https://github.com/monero-project/monero/tree/master/src/common). It contains code for DNS, software update, file system, performance timing, more performance timing, a thousand-line file called util, which I guess was just named that for the lols because why not, thread pools, JSON, more JSON, password management, HTTP connection code again, which, incidentally, actually depends on that aforementioned epee HTTP code, internationalization anyway. So  what constitutes "common" code, again, when, for example, the core Monero crypto code can be considered just as commonly useable by other modules as anything that could be called common? And this is the big deal--anyone who wants to use code which is entangled with common must import, for example, DNS resolution code like libunbound, which is a dependency that you don't necessarily want to have to import if you're just trying to do some cryptography.

A future path for epee and common: So epee and common are too big to fail, by modern parlance, and rather than attempt to refine them or save them or whatever, we have to just break them apart. And the correct way to do this, the correct way to build code like this, is to build top-level, like root-level modules, and they should be applied, or, what should be done is that a specific problem domain, a very concrete set of problems, should be delineated and used to come up with a name for this code module, and that name should be rigorous enough to describe everything that actually lives within there. So relatively good examples of well-contained modules at the high level or the root level are [source/RingCT](https://github.com/monero-project/monero/tree/master/src/ringct) and simplewallet. Of course, [RingCT](https://www.getmonero.org/resources/moneropedia/ringCT.html) has some variable naming issues, but anyway-- if we don't do this, code keeps getting added to these ambiguously named domain scopes or these namespaces. And it ends up growing. The actual domain of that scope is invisible and not well-specified, so it ends up kind of invisibly or covertly growing and especially with tons and tons of contributors who aren't centrally coordinated in any manner. 

And now I get to the really fun part. So wallet2 is a Monero wallet implementation class that's used by virtually every Monero wallet that's out there, except for MyMonero. So it contains all sorts of stuff that it shouldn't necessarily contain or which there should be at least some sort of separate implementation that doesn't contain that stuff, so like address book and persistence and very specific runtime structures. It's a full wallet, but it also contains logical branches to light wallet code which were written by another contributor, a very eminent contributor, quite a while ago. But I already know that that code is not really in use by anyone because there's an assertion in that code that has the inverse condition, logical condition that it should. And so if anyone were running that code their code would be crashing. So, basically, no one's really even maintaining it and there's all this dead code that's in wallet2. And in addition, it has some other big issues, like there are a bunch of data structures that are defined in Wallet2 that should be much more generalized to Monero itself.

And then--this is a really big one--most people don't realize this but the actual literal serialization format of transactions on the wire is actually very specific to C++ structs. So in MyMonero, back in the day, before, not too long ago but, when all this stuff was implemented in JavaScript, we had to literally mimic the byte-for-byte format. We had to construct it by hand, and that doesn't make sense for a global protocol. So This serialization has to occur to compute the hashes to sign for the transaction submission to the network. But Wallet2 has all of this reusable code that's just bound up inside of it that is actually specific to Monero and not specific to wallet2, but in order to use it, you have to take on all of these dependencies and all of this complicated code. So there's code that everyone else wants to use, which can't be used right now without implementing all of wallet2, like calculating transaction fees and waits. If we didn't do this, if everyone used different fees, then adversaries or forensic analysts would be able to look at the blockchain and say, "Hey, it's pretty obvious that whoever's making all these transactions is using this client because that's how they calculate fees." So those should all be the same. For the same reason: decoy selection, like actual input selection for constructing rings; output scanning, scanning the blockchain with your viewkey; subaddress expansion; -I'm actually going to zoom through these ebcause there are way too many, I actually had thee pages of these- daemon and server integration, like networking and parsing; multisig key exchange implementation; account class integration for key generation and management; payment ID parsing; payment ID construction, although you can go through core crypto for that; purse subaddress; balance calculation; the status of transactions; parsing the serialized transaction strings; signing transactions; constructing transactions. And if you guys ever want to go crazy, take a look at createtransactions2 in wallet2. It's literally the longest function I've ever seen. It's huge. So if people construct transactions in different ways then they can be fingerprinted by the way that they construct transactions, so this is actually sort of like a fungibility threat to Monero itself.
More examples: spend and reserve proof derivations; URI construction and parsing; fork specific information and behavior toggles, which, obviously, everyone wants to use; data signing; and a lot of other cool things. And then there's this other weird thing called-- well, I shouldn't probably have said it's weird, but some people came along and built this thing called src/wallet/api for the GUI, which is actually something that kind of hangs on to an instance of wallet2 and then provides another API that is supposed to then be stable or something. But it lives within the same repository, so why isn't the interface for that on wallet2 itself? That's kind of the point of class interfaces. And wallet/api contains a whole bunch of other functionality like a wallet manager and an actual interface to the wallet. And all these things should basically already be in wallet2 or wallet2 should be at a lower level. So a bunch of integrators interact with this wallet API but they ought to have been coded to wallet2, and new integrators don't know that they probably shouldn't actually be using wallet/api.

So one example of an integration that, I think, is well-justified that would end up needing to use a bunch of this wallet2 bound implementation is a light wallet server, which is basically like something that sits in front of a node and does the scanning for you, so you don't have to always be scanning on your actual device. You can have a server at home that's scanning for you. So we built and released an opensourceable version of the server. It's currently awaiting final reviews for a pull request. But wallet2 contains implementation that that light wallet server needs like obtaining decoy outputs and the selection distribution for actually constructing ring signatures, scanning outputs, and then payment ID decryption of the payment IDs that are actually on transactions. So we also wanted to use a bunch of the wallet2 code in order to implement our wallet, trans-piling all that stuff to ASMJS or WebAssembly. And wallet2 already contains a lot of that light wallet implementation like I mentioned, but we couldn't really use it because of its complexity. So I was thinking, "Could we eventually converge the MyMonero code and the Monero code?"So I spent quite a while factoring wallet2, all the transaction construction stuff and I ran into this problem--I actually succeeded in doing this a number of times, eventually, it was like, I think, three times total--but the pace of Monero development itself meant that the work that I had to do to factor it or reorganize things or whatever had to be redone a couple times in certain cases. And I ended up just not doing the pull request. It effectively became a full-time job for me where pace of Monero development meant that I could never actually get to the point where I could do my actual full-time job at the same time as working on the Monero code. And this is actually a pattern I've noticed with people that try to work with the Monero code. So my interim creative solution was actually literally rewriting by hand the JavaScript code that we had implemented on top of that core crypto stuff. I wrote that in C++ and then I trans piled that into JavaScript. And now what we can do is use the C++ on every platform that can run that natively like iOS and then for our webwallet, for example we can use the same code transpiled. 

So I'm actually hooking into the same underlying crypto-note utils transaction construct TX code entry point that Wallet2-- create transaction two is hooking into. But there is so much additional code that should converge. So I ended up coming up with this thing called core CPP which is much more sustainable than the handwritten javascript because it shares a lot of code with the Monero C++ core now. But it's not a perfect solution. There's still a divergence of code. And it actually has to embed a strip-down version of the Monero core itself because obviously, you can't keep all of those dependencies and all of the different things that--it's just so much additional code that most integrators would just not need. So currently, core-cpp powers a bunch of light-wallet applications and even some full-wallet applications who just connect to nodes. But they need utility Monero code even for a full wallet. So this just goes to show that Wallet2 is not exactly usable or the most viable option for even full-wallet implementers. And it used to be the case there were a lot of reports of people who were just kind of giving up on integrating Monero into their product or into their service. And nowadays we don't really hear too many reports of that anymore. And I think it's partially to do with this. If you guys want to check it out, core-cpp is transpiled to Javascript. And it's the new Core JS that we have. 

So I want to propose some solutions for the situation that we're in. I suggest that we do a simple algebraic factoring of wallet two. Sometimes when people say refactor they actually mean rewrite. We shouldn't do that. That's a bad idea, probably, unless there's some hero that comes along who's actually capable of doing it. But simple algebraic factoring, just tease things apart, create pure functions which don't modify the state of an object but which takes state and return results. And that way anyone can use those at that point. And then I suggest that we factor a wallet-base out of wallet2 and then we inject dependencies or hooks for the persistence. And we also extract the address book and the data structures and stuff like that. We can move Wallet API to the GUI repository. Or actually, better, we should extract the useful code from it, add it to wallet2 or wallet_base and then have the GUI code and all other applications have the sort of guideline of using the wallet2 object directly if they want to. Or they can use wallet_base, or just inherit from wallet_base. I see you're a programmer because you're nodding. You know exactly what I'm talking about. So wallet_manager, for example, doesn't really belong in the core Monero code. Simplewallet just uses wallet2 directly. That's evidence that we don't really need this additional API thing on top. And to go further we could extract simplewallet and other non-Monero generic code from the existing singular repository that we have on GitHub and then move that into separate repositories and then create a very stripped-down core Monero library. I guess, in the future, as Ricardo was saying, people are going to move to Rust. We could use this core Monero library and maybe do FFI binding into it or something like that. I think we should create a libwallet which probably embeds this libmonerocore. And then that should contain the actual wallet_base and stuff that other people are going to want to use, a bunch of those factored pure functions and things like that. And we should probably split the daemon in the lightwallet server and the RPC server from libmonerocore either into their own repositories ideally, probably. That's what I would do. Or they could probably live in a single repository like a command-line repository. So some food for thought. 

So some food for thought. And, how I'm I doing on time? Five minutes.

So code improvements to Monero have significant value for the ecosystem, not just in terms of growth but in terms of the pace and the efficiency of the actual progress on our own official apps and the actual functionality and the actual implementation that we've made so far. There's this quote from a book named Hackers and Painters by Paul Graham. Paul Graham is this Lisp hacker, and he founded Y Combinator. The quote is "cruft breeds cruft." So it's the idea that software entropy, when an entropy is higher, it's going to increase based on the existing amount of entropy. So it's harder to change code with more entropy. When you try to change it, it always increases the entropy usually unless you factor and reduce it. So I think that, I mean, kind of sounds far-fetched but personally I think that increasing code entropy, because it looks kind of innocent or there's plausible deniability associated with it, I think that because it can stop the pace of progress of Monero, I think it could actually be considered an attack vector on Monero. Because progress will become harder, we're going to have to stop at a certain point and just completely rewrite stuff, and that can actually kill projects. That's killed early browser projects. There are many projects that were just killed by them getting to the point where the existing team was like, "Look, we can't really do this anymore. We're going to need to rewrite this." And then, they try, and they don't really have their eye on the ball, or they don't go completely to the finish line, and they end up just giving up. So that can happen. This could be an actual threat to Monero.

So a big contributing factor to the complex architecture is that the developers are oftentimes not continuously confirming the problem that they're solving while they're writing code. It's like when we add code to a specific location, are we adding it there because we're lazy and we don't want to open up the other file and figure out the proper way to do it, or are we adding it because that's the right place to put it? So easy is not the same as simple, and there's this other very eminent software architect, Rich Hickey, who says, "Choose easiness along the simplicity path." So always prioritize simplicity, but choose the thing that's going to be easy along that path. And so one thing that vtnerd mentioned is that many of these issues center on dependencies, what dependencies they have. So much of this code wasn't really written to limit its usage of dependencies or thinking about how some minor change in the specification is going to require a massive change to how the code is actually implemented or integrated with. And code should ideally be able to be written once, and it should be able to live forever. That's the idea behind it. And so naming things is super important to that.

So in the future, there's a Push to Factor by myself or by me, vtnerd, another individual, ndorf, who is in the audience as well. I mentioned some of my past efforts like the creation of wallet3, some pure functions, and minimal Monero core. There are upcoming attempts at improving code quality by woodser who's right there and vtnerd. And then, there's just very deep community support already like moneromooo and hyc and Fluffy Pony. Everyone's on board. It's just a question of who's going to actually do this? But I don't think that's quite good enough. I think that because of the fact that this is so critical to our future and because it's so beneficial to us, I think that we need to make it a tradition in Monero itself to celebrate work on simplifying and improving our code quality. So please, everyone, feel free to join us for discussion about factorization on IRC in #monero-dev. More and more people are realizing how important this work is. And in summary, there's just lots of value to factoring our code, keeping it low entropy, keeping it simple and accessible, but there are very specific, unique challenges to doing this in a project that's as fast-moving and as decentralized and as sort of free and open as Monero is. And I do think that we'll reach a point where we're going to have to rewrite a bunch of stuff that might end up being the case that will just kind of go to Rust immediately. But it's going to become a problem. There are really simple ways to solve this, and we have to integrate those solutions, or those methods of solution, into our daily practices as developers instead of pushing it to the future. And we must destroy epee and src/common but lovingly, and we must pour a Barolo for them -a little inside joke. Thank you. 

[applause]

Any questions? I think I might have like one minute for one question.

Actually, we have a little bit, yeah, does anybody have any quick questions for Paul before we get going? We have at least one over here, wonderful.

Question: I mean, you mentioned IRC and #monero-dev, of course. Is there, I mean, given the scope of the project IRC itself, due to the temporal nature, might not be the best for potentially planning and tracking over progress? Is there an issue or--I don't know--like an EPIC or something that we can potentially watch and chime into?

So part of the problem with that is that we could call out specific areas of the code that need attention. But they're going to change relatively quickly. So I think it needs to be a living effort, and we need a more flexible approach. I do think that issue tracking is applicable. I think it's a good idea, and it'll be useful. But the people who are involved in that are going to have to be updating that stuff. And in some cases, it's just the case that it's more efficient for whoever notices the issue to just fix it right there, because, honestly, that's usually all it takes. And it's usually just the people who are like, "No, I'm not going to do that," like, "I have more important stuff to do." But actually, they don't, necessarily. I think that we might need to change our priorities a little bit in terms of how we write code. It's like we should always be factoring. ABF, always be factoring.

We actually have more time for questions, if anyone can think of anything else. Okay, we have two over there at least.

Question: Well, you know how much this topic means to me as well. So I wonder, kind of as a follow-on to that last question, I wonder whether it might be nice to have a dedicated IRC channel, actually, for this because I think one of the problems with new changes that come along board, is they get mixed up in some conversation, the current kind of things that've been worked on as opposed to that taking a step to the side. And of course, many will still contribute into that channel, as well. But it's kind of like a different mindset, because what you're talking about here is really about a mindset change, I think, as much as it is, so, "Yeah, let's have a new IRC channel" and work on that.

Yeah, so I actually made one, #monero-newlibs, but it's actually because of the fact that this needs to be integrated into our culture in a way. It started to occur to me that maybe it shouldn't be separate, at least not right now. There wasn't enough community awareness at the time, I think, to really make that an effective strategy. But I think that as this-- I mean, more and more people are starting to become involved in this. So I think it could actually make sense. I think that's a good idea. So that's #monero-newlibs. 

There's one more back there.

Question: You kind of ended on a dark note, yeah the problem is getting worse. And so I mean, it's a limited, very limited pool of people. There's a lot of contributors, but I don't think that there's very many people who have a good grasp of factoring or a grasp for the functionality of the whole codebase, so they dont have a good perspective on where things where should belong, necessarily. And so, I mean, you mentioned a few people, and I was just curious if you thought-and in your response to questions, you've indicated you think it should it be a kind of group effort, and change of mindset, but I thought-I was just curious if you thought it's worth trying to convince a single person to kind of-

I've already tried. I've been working on that for two years.

--So you don't think that's the way to go, I guess?

No, no. I don't think it's right either. I don't think it's right, and I don't think it's the solution either, because it's not just the case that the responsibility to factor the entire Monero codebase cannot fall on the shoulders of one individual. But it's also the case that that's not sustainable. That's not the real solution, because more people are just going to come and add code on top of their beautiful effort. So I do think it has to be like a grassroots thing. It has to be ground up. But I think, also, that the Monero codebase is actually not that crazy in terms of its functional scope and its organization. I think that if you were to, as a sort of disinterested engineer, come into wallet2 and take a look at it, you'd be able to see right off the bat that there are a whole bunch of functions that literally just can be extracted as pure functions very, very easily. And if you know a little bit about Monero, you'd be able to see, as that engineer looking at wallet2, that those are things that other people aren't going to want to use, so. Does that make sense? Yeah.

We have time for one last question, over here.

You quite nicely presented what the functionality of epee and common currently contains. Do you have a proper document spec'ing this out, or is this what you wrote down basically?

Yeah, that was my analysis, my little observation of what it does. But, I mean, honestly, I could list out all the files for you. I could list out all the functions and all the integrators of those things, but, again, Monero is very fluid. It changes all the time. That's one of the problems with writing documents and being like, "Hey, this is..." It needs to be flexible. It needs to be like a group of people who are actually involved in it.

So the problem I have encountered with bunging tree factor,either functions in epee or common, is that I simply don't know where else to put them.


Right. Well, so I can go back through some of the examples there, but generally speaking, the idea is what you want to do is identify the problem domain that that code is involved in solving. And then you figure out how to describe that in a very concrete, rigorous manner. And then you just make--don't be afraid to make a top-level, root-level module with that name, and just put it in there. Like wallets, for example, is a pretty good module name, but the responsibility is on the programmer to make sure that whatever they put in there is actually appropriate. Yeah, it takes practice. It took me years to really perfect, not perfect, I haven't perfected it but sort of get where I felt like I knew what I was doing. 

All right, well, everybody. Let's thank Paul again. Thanks. 
